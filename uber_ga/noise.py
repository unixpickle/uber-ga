"""
Deterministic mutation noise generation.
"""

from collections import OrderedDict

import numpy as np
import tensorflow as tf

# pylint: disable=R0903
class NoiseSource:
    """
    A deterministic noise generator.
    """
    def __init__(self, seed=1337, size=(1 << 26), max_cache=(1 << 29)):
        state = np.random.RandomState(seed=seed)
        self.noise = state.normal(size=size).astype('float32')
        self._cache = OrderedDict()
        self._max_cache = max_cache

    def block(self, size, seed):
        """
        Generate a block of noise for the given seed.
        """
        state = np.random.RandomState(seed=seed)
        indices = state.randint(0, high=self.noise.shape[0], size=size)
        return self.noise[indices]

    def cumulative_block(self, size, mutations, write_cache=True):
        """
        Generate a block of noise representing the sum of
        the blocks of noise generated by the seeds.

        Args:
          size: the size of the parameter vectors.
          mutations: a sequence of (seed, scale) tuples.
          write_cache: if True, the prefix is cached.

        This caches seed prefixes, i.e. the sum of all but
        the last mutation.
        """
        if not mutations:
            return np.zeros(size, dtype='float32')
        final_block = self.block(size, mutations[-1][0]) * mutations[-1][1]
        if len(mutations) == 1:
            return final_block
        cache_key = tuple(mutations[:-1])
        if cache_key in self._cache:
            return self._cache[cache_key] + final_block
        prefix = self.cumulative_block(size, mutations[:-1], write_cache=False)
        if write_cache:
            self._cache[cache_key] = prefix
            self._evict_cache()
        return prefix + final_block

    def _evict_cache(self):
        while self._cache_size() > self._max_cache:
            self._cache.popitem(last=False)

    def _cache_size(self):
        return sum(x.shape[0] for x in self._cache.values())

class NoiseAdder:
    """
    A context manager that temporarily adds noise to some
    TensorFlow variables.
    """
    def __init__(self, sess, variables, noise):
        self._sess = sess
        self._variables = variables
        self._noise = noise
        self._placeholders = [tf.placeholder(v.dtype, shape=v.get_shape()) for v in variables]
        self._assigns = [tf.assign(v, ph) for v, ph in zip(variables, self._placeholders)]
        self._mutations = None
        self._old_vals = None

    def seed(self, mutations):
        """
        Set the mutations used by this context manager.

        Returns self for convenience.
        """
        self._mutations = mutations
        return self

    def __enter__(self):
        size = int(np.sum(np.prod([x.value for x in v.get_shape()]) for v in self._variables))
        noise = self._noise.cumulative_block(size, self._mutations)
        self._old_vals = self._sess.run(self._variables)
        new_vals = []
        for old_val in self._old_vals:
            sub_size = int(np.prod(old_val.shape))
            new_vals.append(old_val + noise[:sub_size].reshape(old_val.shape))
            noise = noise[sub_size:]
        self._set_values(new_vals)
        return self

    def __exit__(self, *_):
        self._set_values(self._old_vals)

    def _set_values(self, values):
        self._sess.run(self._assigns, feed_dict=dict(zip(self._placeholders, values)))

def noise_seeds(num_seeds):
    """
    Generate random seeds for NoiseSource.block().
    """
    return [int(x) for x in np.random.randint(0, high=2**32, size=num_seeds)]
